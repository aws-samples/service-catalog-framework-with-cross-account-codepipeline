AWSTemplateFormatVersion: "2010-09-09"
Description: An example CloudFormation template for Fargate.
Parameters:

  VPC:
    Type: AWS::EC2::VPC::Id
  SubnetA:
    Type: AWS::EC2::Subnet::Id
  SubnetB:
    Type: AWS::EC2::Subnet::Id
  # Certificate:
  #   Type: String
  #   # Update with the certificate ARN from Certificate Manager, which must exist in the same region.
  #   Default: 'arn:aws:acm:region:123456789012:certificate/00000000-0000-0000-0000-000000000000'
  Registry:
    Type: String
    Default: acme
  Image:
    Type: String
    # Update with the Docker image. "You can use images in the Docker Hub registry or specify other repositories (repository-url/image:tag)."
  ServiceName:
    Type: String
    # update with the name of the service
    Default: MyService
  ContainerPort:
    Type: Number
    Default: 8080
  LoadBalancerPort:
    Type: Number
    Default: 80
  HealthCheckPath:
    Type: String
    Default: /
  HostedZoneName:
    Type: String
    Default: company.com
  Subdomain:
    Type: String
    Default: myservice
  # for autoscaling
  MinContainers:
    Type: Number
    Default: 2
  # for autoscaling
  MaxContainers:
    Type: Number
    Default: 10
  # target CPU utilization (%)
  AutoScalingTargetValue:
    Type: Number
    Default: 50
  Repository:
    Type: String
    Default: acme
  CPUMemory:
    Type: String
    Description: CPU Memory (vCPU/RAM)
    AllowedValues:
      - "256/1GB"
      - "512/1GB"
      - "1024/2GB"
      - "2048/4GB"
      - "4096/8GB"
  MinimumHealthyPercent:
    Type: Number
    Description: Specifies the lower limit of the number of tasks that must remain running and healthy during a deployment. 
  MaximumPercent:
    Type: Number
    Description: Specifies the upper limit of the number of tasks that must remain running and healthy during a deployment. 
  DesiredCount:
    Type: Number
    Description: Specifies the number of tasks that you want the service to maintain
  HealthCheckGracePeriodSeconds:
    Type: Number
    Description: Specifies the amount of time to allow the tasks in a service to stabilize before the health check system starts evaluating the task's health status.
  HealthCheckIntervalSeconds:
    Type: Number
    Description: The amount of time, in seconds, during which no response means a failed health check.
  HealthCheckTimeoutSeconds:
    Type: Number
    Description: The amount of time, in seconds, during which no response means a failed health check.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: VPC Parameters
        Parameters:
          - VPC
          - SubnetA
          - SubnetB
      - Label:
          default: ECS Service Parameters
        Parameters:
          - MinimumHealthyPercent
          - MaximumPercent
          - DesiredCount
          - HealthCheckGracePeriodSeconds

      - Label:
          default: Elastic Container Service Parameters
        Parameters:
          - Registry
          - Repository
          - ServiceName
      - Label:
          default: Container Parameters
        Parameters:
          - CPUMemory
          - Image
          - ContainerPort
      - Label:
          default: Autoscaling Parameters
        Parameters:
          - MinContainers
          - MaxContainers
          - AutoScalingTargetValue
      - Label:
          default: Target Group Parameters
        Parameters:
          - HealthCheckIntervalSeconds
          - HealthCheckTimeoutSeconds
      - Label:
          default: LoadBalancerProperties
        Parameters: 
          - HealthCheckTimeoutSeconds
          - HealthCheckGracePeriodSeconds
          - HealthCheckIntervalSeconds
          - LoadBalancerPort
          - HealthCheckPath
      - Label:
          default: Route53 Parameters
        Parameters:
          - HostedZoneName
          - Subdomain
Resources:
  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Join ['', [!Ref ServiceName, Cluster]]
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: LogGroup
    Properties:
      # Name of the task definition. Subsequent versions of the task definition are grouped together under this name.
      Family: !Join ['', [!Ref ServiceName, TaskDefinition]]
      # awsvpc is required for Fargate
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      Cpu: !Select [0, !Split ["/",!Ref CPUMemory]]
      Memory: !Select [1, !Split ["/",!Ref CPUMemory]]
      ExecutionRoleArn: !Ref ExecutionRole
      TaskRoleArn: !Ref TaskRole
      ContainerDefinitions:
        - Name: !Ref ServiceName
          Image: !Sub "${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${Repository}:${Image}"
          PortMappings:
            - ContainerPort: !Ref ContainerPort
          # Send logs to CloudWatch Logs
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref LogGroup
              awslogs-stream-prefix: ecs
  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['', [!Ref ServiceName, ExecutionRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
  TaskRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['', [!Ref ServiceName, TaskRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      # ManagedPolicyArns:
      #   -
      # Policies:
      #   -
  AutoScalingRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['', [!Ref ServiceName, AutoScalingRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceAutoscaleRole'
  ContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Join ['', [!Ref ServiceName, ContainerSecurityGroup]]
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref ContainerPort
          ToPort: !Ref ContainerPort
          SourceSecurityGroupId: !Ref LoadBalancerSecurityGroup
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Join ['', [!Ref ServiceName, LoadBalancerSecurityGroup]]
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref LoadBalancerPort
          ToPort: !Ref LoadBalancerPort
          CidrIp: 0.0.0.0/0
  Service:
    Type: AWS::ECS::Service
    DependsOn:
      - ListenerHTTPS
    Properties: 
      ServiceName: !Ref ServiceName
      Cluster: !Ref Cluster
      TaskDefinition: !Ref TaskDefinition
      DeploymentConfiguration:
        MinimumHealthyPercent: !Ref MinimumHealthyPercent
        MaximumPercent: !Ref MaximumPercent
        DeploymentCircuitBreaker:
          Enable: True
          Rollback: True
      DesiredCount: !Ref DesiredCount
      HealthCheckGracePeriodSeconds: !Ref HealthCheckGracePeriodSeconds
      LaunchType: FARGATE
      NetworkConfiguration: 
        AwsvpcConfiguration:
          # change to DISABLED if you're using private subnets that have access to a NAT gateway
          AssignPublicIp: ENABLED
          Subnets:
            - !Ref SubnetA
            - !Ref SubnetB
          SecurityGroups:
            - !Ref ContainerSecurityGroup
      LoadBalancers:
        - ContainerName: !Ref ServiceName
          ContainerPort: !Ref ContainerPort
          TargetGroupArn: !Ref TargetGroup
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: !Ref HealthCheckIntervalSeconds
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckTimeoutSeconds: !Ref HealthCheckTimeoutSeconds
      UnhealthyThresholdCount: 5
      HealthyThresholdCount: 2
      Name: !Join ['', [!Ref ServiceName, TargetGroup]]
      Port: !Ref ContainerPort
      Protocol: HTTP
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: 60 # default is 300
      TargetType: ip
      VpcId: !Ref VPC
  ListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: !Ref LoadBalancerPort
      # This should be HTTPS.  We can't create certificates on internal accounts
      Protocol: HTTP
      # Certificates:
      #   - CertificateArn: !Ref Certificate
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      LoadBalancerAttributes:
        # this is the default, but is specified here in case it needs to be changed
        - Key: idle_timeout.timeout_seconds
          Value: 60
      Name: !Join ['', [!Ref ServiceName, LoadBalancer]]
      # "internal" is also an option
      Scheme: internet-facing
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Subnets:
        - !Ref SubnetA
        - !Ref SubnetB
  # DNSRecord:
  #   Type: AWS::Route53::RecordSet
  #   Properties:
  #     HostedZoneName: !Join ['', [!Ref HostedZoneName, .]]
  #     Name: !Join ['', [!Ref Subdomain, ., !Ref HostedZoneName, .]]
  #     Type: A
  #     AliasTarget:
  #       DNSName: !GetAtt LoadBalancer.DNSName
  #       HostedZoneId: !GetAtt LoadBalancer.CanonicalHostedZoneID
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/ecs/, !Ref ServiceName, TaskDefinition]]
  AutoScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MinCapacity: !Ref MinContainers
      MaxCapacity: !Ref MaxContainers
      ResourceId: !Join ['/', [service, !Ref Cluster, !GetAtt Service.Name]]
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs
      # "The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that allows Application Auto Scaling to modify your scalable target."
      RoleARN: !GetAtt AutoScalingRole.Arn
  AutoScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: !Join ['', [!Ref ServiceName, AutoScalingPolicy]]
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref AutoScalingTarget
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        ScaleInCooldown: 10
        ScaleOutCooldown: 10
        # Keep things at or lower than 50% CPU utilization, for example
        TargetValue: !Ref AutoScalingTargetValue
Outputs:
  Endpoint:
    Description: Endpoint
    Value: !Join ['', ['http://', !GetAtt LoadBalancer.CanonicalHostedZoneID]]